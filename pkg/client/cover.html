
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/smsglobal/smsglobal-go/pkg/client/client.go (92.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package client

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "github.com/smsglobal/smsglobal-go/interface/apiclient"
        e "github.com/smsglobal/smsglobal-go/pkg/error"
        "github.com/smsglobal/smsglobal-go/pkg/logger"
        "github.com/smsglobal/smsglobal-go/types/constants"
        "io/ioutil"
        "math/rand"
        "net/http"
        "net/url"
        p "path"
        "time"
)

var lg = logger.CreateLogger(constants.DebugLevel).Lgr.With().Str("SMSGlobal", "HTTP Client").Logger()

// client defines information that can be used to make a request to SMSGlobal Rest API.
type Client struct {
        method     string
        path       string
        HttpClient apiclient.HTTPClient
        BaseURL    *url.URL
        timeout    time.Duration
        Key        string // API key
        Secret     string // API secret
}

// New returns a new api request handler
func New(key, secret string) *Client <span class="cov8" title="1">{
        baseURL, _ := url.Parse(constants.Host)

        hc := &amp;http.Client{
                Timeout: constants.Timeout * time.Second,
        }

        c := &amp;Client{
                HttpClient: hc,
                BaseURL:    baseURL,
                Key:        key,
                Secret:     secret,
        }

        return c
}</span>

func (c *Client) NewRequest(method, path string, body interface{}) (*http.Request, error) <span class="cov8" title="1">{

        lg.Debug().Msgf("Creating new http request instance")

        rel, err := url.Parse(path)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // append path to existing path "/v2"
        <span class="cov8" title="1">c.BaseURL.Path = p.Join(c.BaseURL.Path, rel.Path)

        // forward query string
        c.BaseURL.RawQuery = rel.RawQuery
        u := c.BaseURL.ResolveReference(c.BaseURL)
        c.method = method

        buffer := new(bytes.Buffer)
        if body != nil </span><span class="cov8" title="1">{
                err := json.NewEncoder(buffer).Encode(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">fmt.Println(u.String())
        req, err := http.NewRequest(method, u.String(), buffer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.Header.Add("Content-Type", constants.ContentType)
        req.Header.Add("Accept", constants.ContentType)
        req.Header.Add("Accept-Charset", "utf-8")
        req.Header.Add("Authorization", c.generateAuthToken())
        req.Header.Add("User-Agent", constants.UserAgent)

        // TODO clean up before MR
        lg.Debug().Msgf("Authorization header: %v", req.Header.Get("Authorization"))

        return req, nil</span>
}

// generateAuthToken Generate authorization token string for each request
func (c *Client) generateAuthToken() string <span class="cov8" title="1">{

        rand.Seed(time.Now().UnixNano())
        timestamp := int(time.Now().Unix())
        nonce := rand.Intn(1000000000)

        resource := c.BaseURL.Path

        // append query params
        if len(c.BaseURL.RawQuery) &gt; 0 </span><span class="cov0" title="0">{
                resource = resource + "?" + c.BaseURL.RawQuery
        }</span>

        <span class="cov8" title="1">lg.Debug().Msgf("Given PATH %+v", resource)

        // raw string for HMAC generation
        auth := fmt.Sprintf("%d\n%d\n%s\n%s\n%s\n%d\n\n", timestamp, nonce, c.method, resource, c.BaseURL.Host, 443)

        // TODO clean up before MR
        lg.Debug().Msgf("Raw auth string: %v", auth)

        // generate new HMAC hash
        h := hmac.New(sha256.New, []byte(c.Secret))

        // write Data to it
        h.Write([]byte(auth))

        // Encode HMAC hash bytes to base64 string
        hash := base64.StdEncoding.EncodeToString(h.Sum(nil))

        return fmt.Sprintf(`MAC id="%s", ts="%d", nonce="%d", mac="%s"`, c.Key, timestamp, nonce, hash)</span>
}

// Do sends an API request adn the API response is JSON decoded and stored in the value pointed to by v, or returned as an error if an API error has occurred.
func (c *Client) Do(req *http.Request, v interface{}) error <span class="cov8" title="1">{

        lg.Debug().Msgf("Sending %s request to %s", c.method, c.BaseURL)

        res, err := c.HttpClient.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                return &amp;e.Error{Message: "Failed to make a request", Code: constants.DefaultCode}
        }</span>

        <span class="cov8" title="1">err = checkResponse(res)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>


        // TODO remove below log lines
        <span class="cov8" title="1">lg.Debug().Msgf("Response received %+v", res)
        lg.Debug().Msgf("Response body %+v", res.Body)

        fmt.Println(res.Body)

        if res != nil &amp;&amp; res.StatusCode != 204 </span><span class="cov8" title="1">{
                defer res.Body.Close()
        }</span>


        <span class="cov8" title="1">if v != nil </span><span class="cov8" title="1">{
                err = json.NewDecoder(res.Body).Decode(v)
        }</span>

        <span class="cov8" title="1">lg.Debug().Msg("HTTP request done")

        return err</span>
}

// checkResponse performs required checks whether there is any error or not
func checkResponse(r *http.Response) error <span class="cov8" title="1">{
        lg.Debug().Msgf("HTTP status code: %d", r.StatusCode)

        //bodyBytes , err := ioutil.ReadAll(r.Body)
        //lg.Debug().Msgf("HTTP response string %s", string(bodyBytes))

        // a successful request status code must be between 200 and 299
        if c := r.StatusCode; http.StatusOK &lt;= c &amp;&amp; c &lt; http.StatusMultipleChoices </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errorResponse := &amp;e.Error{
                Code: r.StatusCode,
        }
        data, err := ioutil.ReadAll(r.Body)

        if err == nil &amp;&amp; data != nil </span><span class="cov8" title="1">{
                err = json.Unmarshal(data, errorResponse)
                if err != nil </span><span class="cov8" title="1">{
                        errorResponse.Message = string(data)
                }</span>
        }
        <span class="cov8" title="1">return errorResponse</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
